
import logger                      from '@rhobweb/console-logger';
import { connect, TypePoolClient } from '@rhobweb/pg-client';
import {
  DB_FIELD_STATUS, DB_FIELD_PID, DB_FIELD_TITLE, DB_FIELD_SYNOPSIS, DB_FIELD_GENRE, DB_FIELD_QUALITY, DB_FIELD_MODIFY_TIME, DB_FIELD_DOWNLOAD_TIME, DB_FIELD_DAY_OF_WEEK, DB_FIELD_POS, DB_FIELD_IMAGE_URI,
  VALUE_STATUS_ERROR, VALUE_STATUS_SUCCESS, VALUE_STATUS_ALREADY, TypeDbProgramItem
}
from './gip_prog_fields';

export type { TypeDbProgramItem } from './gip_prog_fields';
export type TypeQuery = { text: string, values: ( string | number )[] };

const TABLE_PROGRAM           = 'gip_prog.program';
const TABLE_PROGRAM_HISTORY   = 'gip_prog.program_history';
const QUERY_LOAD_PROGRAMS     = `SELECT * FROM ${TABLE_PROGRAM} ORDER BY ${DB_FIELD_POS}`;
const ARR_PROG_FIELD          = [ DB_FIELD_STATUS, DB_FIELD_PID, DB_FIELD_TITLE, DB_FIELD_SYNOPSIS, DB_FIELD_GENRE, DB_FIELD_QUALITY, DB_FIELD_DAY_OF_WEEK, DB_FIELD_IMAGE_URI ];
const ARR_PROG_FIELD_WITH_POS = [ ...ARR_PROG_FIELD, DB_FIELD_POS ];
//const ARR_PROG_HISTORY_FIELD = [ DB_FIELD_STATUS, DB_FIELD_PID, DB_FIELD_TITLE, DB_FIELD_SYNOPSIS, DB_FIELD_DAY_OF_WEEK, DB_FIELD_GENRE, DB_FIELD_QUALITY, DB_FIELD_DOWNLOAD_TIME ];
const ARR_PROG_HISTORY_FIELD_MAP = [
  [ DB_FIELD_STATUS,        DB_FIELD_STATUS      ],
  [ DB_FIELD_PID,           DB_FIELD_PID         ],
  [ DB_FIELD_TITLE,         DB_FIELD_TITLE       ],
  [ DB_FIELD_SYNOPSIS,      DB_FIELD_SYNOPSIS    ],
  [ DB_FIELD_GENRE,         DB_FIELD_GENRE       ],
  [ DB_FIELD_QUALITY,       DB_FIELD_QUALITY     ],
  [ DB_FIELD_DOWNLOAD_TIME, DB_FIELD_MODIFY_TIME ],
  [ DB_FIELD_IMAGE_URI,     DB_FIELD_IMAGE_URI   ],
];
const ARR_PROG_HISTORY_FIELD        = ARR_PROG_HISTORY_FIELD_MAP.map( el => el[ 0 ] );
const ARR_PROG_HISTORY_SOURCE_FIELD = ARR_PROG_HISTORY_FIELD_MAP.map( el => el[ 1 ] );

const ARR_HISTORY_STATUSES  = [ VALUE_STATUS_SUCCESS, VALUE_STATUS_ERROR, VALUE_STATUS_ALREADY ];

const UPDATE_QUERY_TEXT     = `
WITH upd AS ( UPDATE ${TABLE_PROGRAM} SET ${DB_FIELD_STATUS} = $1 WHERE ${DB_FIELD_PID} = $2 RETURNING * )
INSERT INTO ${TABLE_PROGRAM_HISTORY} ( ${ARR_PROG_HISTORY_FIELD.join(',')} ) SELECT ${ARR_PROG_HISTORY_SOURCE_FIELD.join(',')} FROM upd
`;

// When closing down
//await end(); // Terminate the connection pool

/**
 * @returns promise to return an array of program items in DB format.
 * @exception if the DB connection or the query fails.
 */
export async function loadProgs() : Promise<TypeDbProgramItem[]> {
  let dbClient  = null;
  let rawResult = null;
  let programs  = [];

  try {
    dbClient  = await connect();
    rawResult = await dbClient.query( QUERY_LOAD_PROGRAMS );
    programs  = rawResult.rows as TypeDbProgramItem[];
  }
  catch ( err ) {
    const errMessage = ( dbClient ? 'query failed' : 'connect failed' );
    logger.log( 'error', 'loadProgs: ', errMessage );
    throw err;
  }
  finally {
    if ( dbClient ) {
      await dbClient.release();
    }
  }

  //const SYNOPSIS = 'My synopsis which is really long as I want to try to get a horizontal scroll bar to be displayed if I can but it is proving troublesome';
  //const programs = [
  //  { pid: 'pid1234', title: 'MyProg', synopsis: SYNOPSIS, day_of_week: '***', genre: 'C', quality: 'Normal' },
  //];

  return programs;
}

/**
 * @param arrProgram : array of program items;
 * @returns a query object that will insert the programs into the DB.
 */
function genSaveQuery( arrProgram: TypeDbProgramItem[] ) : TypeQuery {
  const query : TypeQuery = {
    text:   '',
    values: [],
  };
  const strInsQuery                        = `INSERT INTO ${TABLE_PROGRAM} ( ${ARR_PROG_FIELD_WITH_POS.join( ', ' )} )`;
  const arrPos   : string[][]              = [];
  const arrValue : ( string | number )[][] = [];
  arrProgram.forEach( ( program, i ) => {
    arrValue[ i ] = arrValue[ i ] || [];
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore 'field' only contains valid property names
    ARR_PROG_FIELD.forEach( field => arrValue[ i ].push( program[ field ] ) )
    arrValue[ i ].push( i ); // Add the pos field value
  } );
  let iParam = 1;
  arrValue.forEach( ( arrRecordValue, i ) => {
    arrPos[ i ] = arrPos[ i ] || [];
    arrRecordValue.forEach( val => {
      arrPos[ i ].push( `$${iParam}` );
      ++iParam;
      query.values.push( val );
    } );
  } );
  query.text = `${strInsQuery} VALUES( ${ arrPos.map( arrRec => arrRec.join( ',' ) ).join( '),(' ) } ) RETURNING *`;

  return query;
}

/**
 * @param program : a program item;
 * @returns a query object that will update the programs into the DB or null if no updates are required.
 */
function genUpdateQuery( program: TypeDbProgramItem ) : ( TypeQuery | null ) {
  let   query : ( TypeQuery | null ) = null;
  const newStatus = program[ DB_FIELD_STATUS ];
  const pid       = program[ DB_FIELD_PID ];

  if ( ARR_HISTORY_STATUSES.indexOf( newStatus ) >= 0 ) {
    query = {
      text:   UPDATE_QUERY_TEXT,
      values: [ newStatus, pid ],
    };
  }

  return query;
}

/**
 * @param arrProgram : array of program items;
 * @return array of query objects to update the database.
 */
function genUpdateQueries( arrProgram: TypeDbProgramItem[] ) : TypeQuery[] {
  const arrQuery : TypeQuery[] = [];

  arrProgram.forEach( prog => {
    const query = genUpdateQuery( prog );
    if ( query ) {
      arrQuery.push( query );
    }
  } );

  return arrQuery;
}

async function runDeleteQuery( dbClient : TypePoolClient ) {
  let numRecordsDeleted = 0;

  try {
    const strDelQuery = `DELETE FROM ${TABLE_PROGRAM}`;
    const result      = await dbClient.query( strDelQuery );
    numRecordsDeleted = result.rowCount;
  }
  catch ( err ) {
    logger.log( 'error', 'runDeleteQuery: ', (err as Error).message );
    throw err;
  }

  return numRecordsDeleted;
}

/**
 * @param {Object} with properties:
 *           - programs :  array of program items;
 * @returns array of DB program items.
 */
export async function saveProgs( { programs } : { programs: TypeDbProgramItem[] } ) : Promise<TypeDbProgramItem[]> {
  let dbClient = null;
  let result   = [];

  try {
    dbClient = await connect();

    await runDeleteQuery( dbClient );
  
    if ( programs.length > 0 ) {
      const saveQuery = genSaveQuery( programs );
      const rawResult = await dbClient.query( saveQuery );    // TODO: Log response and check for error
      result = rawResult.rows;
    }
  }
  catch ( err ) {
     logger.log( 'error', 'saveProgs: ', ( err as Error ).message );
     throw err;
  }
  finally {
    if ( dbClient ) {
      await dbClient.release();
    }
  }

  return result;
}

export async function updateProgs( { programs } : { programs: TypeDbProgramItem[] } ) : Promise<void>
{
  let dbClient : TypePoolClient | null = null;

  try {
    dbClient = await connect();
    const arrUpdateQuery = genUpdateQueries( programs );
  
    await dbClient.begin();

    arrUpdateQuery.forEach( async updateQuery => {
      await dbClient.query( updateQuery ); // dbClient must be non-null here
      //console.log( `Update OK: `, rawResult );
    } );

    await dbClient.commit();
  }
  catch ( err ) {
    logger.log( 'error', `Update failed: `, err );
    if ( dbClient ) {
      await dbClient.rollback();
    }
  }
  finally {
    if ( dbClient ) {
      await dbClient.release();
    }
  }
}

export default {};
